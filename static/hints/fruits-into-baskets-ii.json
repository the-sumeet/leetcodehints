{
  "hints": [
    {
      "content": "Start by understanding the input arrays: `fruits` and `baskets`. Each index in these arrays corresponds to a specific fruit type and basket capacity respectively. Make sure to keep track of which fruit types have been placed in baskets."
    },
    {
      "content": "Consider how you will iterate through the `fruits` array. You need to check each fruit type against the available baskets from left to right. Think about how you can mark baskets as used once a fruit type is placed."
    },
    {
      "content": "Remember that each basket can hold only one type of fruit. This means once a basket is filled, it cannot be reused for another fruit type. How will you keep track of this in your implementation?"
    },
    {
      "content": "When checking if a fruit can be placed in a basket, ensure that the basket's capacity is greater than or equal to the fruit's quantity. You might want to use a simple if-statement to check this condition."
    },
    {
      "content": "Think about how you will handle the case where a fruit type cannot be placed in any of the baskets. You should have a counter or a list to keep track of the unplaced fruit types."
    },
    {
      "content": "Consider edge cases such as when all baskets are smaller than the smallest fruit type. What should your function return in this scenario? How will you ensure that your solution handles this correctly?"
    },
    {
      "content": "As you iterate through the `fruits`, if you find a suitable basket, you should break out of the inner loop to move to the next fruit. This will prevent unnecessary checks once a fruit has been placed."
    },
    {
      "content": "You might want to use a boolean array or a set to track which baskets have been filled. This will help you quickly determine if a basket is available for the next fruit type."
    },
    {
      "content": "After processing all fruit types, the final step is to return the count of unplaced fruit types. Make sure to think about how you will calculate this number efficiently."
    },
    {
      "content": "Your final implementation should loop through both arrays, checking each fruit against the baskets, marking baskets as used, and counting unplaced fruits. Remember to consider the constraints provided in the problem statement."
    }
  ],
  "questionNotes": [
    "Constraints: n == fruits.length == baskets.length",
    "1 <= n <= 100",
    "1 <= fruits[i], baskets[i] <= 1000",
    "Each fruit type must be placed in the leftmost available basket with sufficient capacity.",
    "Each basket can hold only one type of fruit.",
    "Return the number of fruit types that remain unplaced after all possible allocations."
  ]
}