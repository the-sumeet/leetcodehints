{
  "hints": [
    {
      "content": "Start by understanding what a beautiful subarray is. A subarray is considered beautiful if all its elements can be turned into zero using the specified operation. Think about how the operation affects the elements."
    },
    {
      "content": "Notice that the operation allows you to subtract powers of two from pairs of elements. This means that for a subarray to be beautiful, the binary representation of its elements must share common bits that are set to 1."
    },
    {
      "content": "Consider how you can determine if all elements in a subarray can be reduced to zero. You might want to analyze the bitwise AND operation on the elements of the subarray. If the AND of all elements is zero, then they can be made beautiful."
    },
    {
      "content": "Think about how to efficiently check all possible subarrays. A brute force approach would involve checking every possible subarray, which could be inefficient. Consider how you can use a sliding window or two-pointer technique to optimize this."
    },
    {
      "content": "Remember that subarrays where all elements are initially zero are also considered beautiful. Make sure to handle this case explicitly in your solution."
    },
    {
      "content": "As you implement your solution, keep track of the number of beautiful subarrays you find. You can use a counter to accumulate the count as you identify each beautiful subarray."
    },
    {
      "content": "When checking subarrays, consider using a bitmask to represent the bits that are set in the current subarray. This will help you determine if you can perform the operation on the entire subarray."
    },
    {
      "content": "You may want to preprocess the array to store the cumulative bitwise AND of elements up to each index. This could help in quickly checking if a subarray is beautiful."
    },
    {
      "content": "Think about edge cases, such as when the array contains only zeros or when it contains large values. How does this affect your approach to finding beautiful subarrays?"
    },
    {
      "content": "Finally, ensure that your solution runs within the time limits given the constraints. Aim for a solution that is better than O(n^2) by leveraging bitwise operations and efficient subarray checks."
    }
  ],
  "questionNotes": [
    "Subarrays where all elements are initially 0 are considered beautiful.",
    "You can choose any two different indices i and j.",
    "You can choose a non-negative integer k such that the k-th bit is 1.",
    "1 <= nums.length <= 10^5 and 0 <= nums[i] <= 10^6."
  ]
}