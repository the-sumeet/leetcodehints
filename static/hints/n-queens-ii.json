{
  "hints": [
    {
      "content": "Start by understanding the constraints of the n-queens problem. Each queen must be placed such that no two queens share the same row, column, or diagonal."
    },
    {
      "content": "Consider how you can represent the chessboard. A simple way is to use a 2D array, but you can also track the positions of queens using arrays for columns and diagonals."
    },
    {
      "content": "Think about how to place queens row by row. You can use a backtracking approach where you try to place a queen in a row and then move to the next row."
    },
    {
      "content": "When placing a queen, check if the column and both diagonals are free. You can maintain sets or arrays to track which columns and diagonals are occupied."
    },
    {
      "content": "Remember that diagonals can be tracked using the properties of their indices. For a queen at (row, col), the diagonals can be identified as (row - col) and (row + col)."
    },
    {
      "content": "Implement a recursive function that attempts to place a queen in each column of the current row. If placing a queen is valid, recursively attempt to place queens in the next row."
    },
    {
      "content": "When you reach a base case where you've placed queens in all rows, increment a count of valid solutions."
    },
    {
      "content": "Don't forget to backtrack! After trying to place a queen in a column, you need to remove it from your tracking structures before trying the next column."
    },
    {
      "content": "Consider edge cases like n = 1, where there is only one way to place a queen, and n = 2 or n = 3, where there are no valid placements."
    },
    {
      "content": "Ensure your solution counts only distinct arrangements. Two arrangements are distinct if they cannot be transformed into one another by rotation or reflection."
    },
    {
      "content": "You can optimize your backtracking by stopping early if you find that a row cannot accommodate any queens due to previous placements."
    },
    {
      "content": "As you build your solution, keep track of the number of solutions found so far and return this count at the end of your recursive function."
    },
    {
      "content": "Think about how to structure your function. You might want a helper function that takes the current row and the tracking structures as parameters."
    },
    {
      "content": "Make sure to test your implementation with various values of n, especially the edge cases and the maximum constraint of n = 9."
    },
    {
      "content": "As a final step, ensure your function returns the total number of distinct solutions found, rather than printing or displaying them."
    }
  ],
  "questionNotes": [
    "Constraints: 1 <= n <= 9",
    "Return the number of distinct solutions, not the solutions themselves.",
    "Ensure that no two queens attack each other: same row, column, or diagonal."
  ]
}