{
  "hints": [
    {
      "content": "Start by understanding the basic operations of a stack. You need to implement a structure that allows you to push, pop, and peek at the top element, as well as retrieve the maximum element efficiently."
    },
    {
      "content": "Consider how you will maintain the maximum value in the stack. A naive approach would be to scan the entire stack each time you need the max, which would be inefficient."
    },
    {
      "content": "Think about using an auxiliary data structure to keep track of the maximum values. This could be another stack that only stores maximums or a variable that updates when you push or pop."
    },
    {
      "content": "When implementing the `push` operation, ensure that you update your max tracking mechanism. If the new value is greater than the current max, you need to update your max accordingly."
    },
    {
      "content": "For the `popMax` operation, you'll need to remove the maximum element from the stack. Consider how you will find and remove this element without losing the order of the other elements."
    },
    {
      "content": "Think about how to handle duplicates in the stack. If you have multiple maximum values, you need to decide which one to pop when `popMax` is called."
    },
    {
      "content": "Make sure to handle edge cases, such as popping from an empty stack or calling `popMax` when there are no elements. What should your methods return in these cases?"
    },
    {
      "content": "Consider the time complexity of your operations. Aim for O(1) for `push`, `pop`, and `top`, and O(n) for `popMax` if you use a simple approach, but think about how you might optimize this."
    },
    {
      "content": "You might want to maintain a list of indices or a second stack to track the maximums in a way that allows you to pop the maximum efficiently."
    },
    {
      "content": "When implementing `peekMax`, ensure that it simply returns the current maximum without modifying the stack. This should be a straightforward read operation."
    },
    {
      "content": "As you build your solution, write unit tests for each operation to ensure they behave as expected, especially for edge cases like popping the last element."
    },
    {
      "content": "Think about the data structure you will use to store the stack. A linked list or array could work, but consider the implications of each on your operations."
    },
    {
      "content": "When implementing `popMax`, you might need to temporarily store values to maintain the order of the stack. Consider how to reinsert elements after removing the max."
    },
    {
      "content": "Remember to keep track of the maximum value efficiently. You might want to push the maximum value onto a secondary stack whenever you push a new element."
    },
    {
      "content": "Your final implementation should allow for all operations to be performed correctly. Make sure to test with various sequences of operations to validate your design."
    }
  ],
  "questionNotes": [
    "Ensure to handle edge cases like popping from an empty stack or calling popMax when there are no elements.",
    "Consider how to manage duplicates in the stack, especially when popping the maximum.",
    "Aim for O(1) complexity for push, pop, and top operations, and think about optimizing popMax."
  ]
}