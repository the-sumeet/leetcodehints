{
  "hints": [
    {
      "content": "Start by understanding the structure of a binary tree. Each node has a value and can have up to two children: a left child and a right child. Familiarize yourself with how to traverse a binary tree."
    },
    {
      "content": "Consider how level order traversal works. Typically, you would visit nodes level by level from top to bottom. Think about how you might modify this to achieve a bottom-up order."
    },
    {
      "content": "You can use a queue to facilitate the level order traversal. As you traverse each level, you can store the values in a temporary list. Remember to process each level before moving to the next."
    },
    {
      "content": "Once you have collected the values for each level in the order you traverse them, think about how you can reverse the order of these levels to achieve the bottom-up effect."
    },
    {
      "content": "Consider edge cases, such as when the tree is empty. How would your approach handle a null root? Ensure your solution can return an empty list in this scenario."
    },
    {
      "content": "As you implement the traversal, keep track of the current level. You may want to use a list of lists to store the values of each level. Each inner list corresponds to a level in the tree."
    },
    {
      "content": "When adding nodes to your queue, remember to enqueue both the left and right children of the current node, if they exist. This will ensure you visit all nodes at each level."
    },
    {
      "content": "After processing all nodes, you should have a list of lists where each inner list contains the values of nodes at that level. Think about how to reverse this list of lists."
    },
    {
      "content": "You might find it helpful to use a stack to reverse the order of the levels. As you pop levels from the stack, you can construct the final output list."
    },
    {
      "content": "Finally, ensure your output format matches the requirements. You need to return a list of lists, with each inner list representing a level from the bottom to the top."
    }
  ],
  "questionNotes": [
    "Return the bottom-up level order traversal of the binary tree.",
    "Output format: list of lists, where each inner list contains node values from one level.",
    "Constraints: 0 <= number of nodes <= 2000, -1000 <= Node.val <= 1000.",
    "Handle the case where the input tree is empty."
  ]
}