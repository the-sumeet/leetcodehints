{
  "hints": [
    {
      "content": "Start by understanding the structure of a binary tree and how pre-order traversal works. In pre-order traversal, you visit the root node first, then the left subtree, followed by the right subtree."
    },
    {
      "content": "Consider how flipping a node affects the traversal. When you flip a node, the left and right children are swapped. Think about how this would change the order of the nodes in the pre-order traversal."
    },
    {
      "content": "Identify the first element of the `voyage` array. This element must match the root of the tree. If it doesn't, you can immediately return [-1] since it's impossible to match the traversal."
    },
    {
      "content": "As you traverse the tree, keep track of the nodes you visit. Use a recursive approach to explore the left and right children of each node. Compare these with the corresponding elements in the `voyage` array."
    },
    {
      "content": "When you encounter a node, check if its left child matches the next expected value in `voyage`. If it does, continue traversing normally. If it doesn't, consider flipping the node."
    },
    {
      "content": "Maintain a list to keep track of the nodes that you flip. Each time you decide to flip a node, add its value to this list."
    },
    {
      "content": "Be cautious of the base case in your recursion. If you reach a null node, simply return true, as it does not affect the traversal."
    },
    {
      "content": "After processing all nodes, check if you've successfully matched the entire `voyage`. If you reach the end of `voyage` without mismatches, return the list of flipped nodes."
    },
    {
      "content": "Think about edge cases, such as when the tree is very small (like a single node) or when the `voyage` is already in the correct order. How does your solution handle these scenarios?"
    },
    {
      "content": "Implement a helper function that performs the recursive traversal and flipping logic. This function should return a boolean indicating whether the traversal matches and update the flip list accordingly."
    }
  ],
  "questionNotes": [
    "The tree nodes are uniquely valued from 1 to n.",
    "The `voyage` array is also uniquely valued and has the same length as the number of nodes in the tree.",
    "Return format: if it's impossible to match the `voyage`, return [-1]. Otherwise, return the list of flipped nodes.",
    "Constraints: 1 <= n <= 100, ensuring the solution should be efficient for n up to 100."
  ]
}