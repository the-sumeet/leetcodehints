{
  "hints": [
    {
      "content": "Start by understanding the structure of the graph. Each node has a value and a list of its neighbors. Think about how you can represent this in your code."
    },
    {
      "content": "Consider how you will traverse the graph. A Depth-First Search (DFS) or Breadth-First Search (BFS) approach could be useful for visiting each node."
    },
    {
      "content": "You need to create a deep copy of each node. This means that for every node you visit, you should create a new node with the same value."
    },
    {
      "content": "Keep track of the nodes you have already cloned. This will help you avoid duplicating nodes and also handle cycles in the graph."
    },
    {
      "content": "Use a mapping structure, like a dictionary, to store the original node to its cloned node mapping. This will allow you to easily find the cloned version of a node when you encounter it again."
    },
    {
      "content": "When you clone a node, you should also clone its neighbors. Make sure to iterate through the original node's neighbors and add the corresponding cloned nodes to the new node's neighbor list."
    },
    {
      "content": "Think about edge cases, such as when the graph is empty or when there is only one node. How will your function handle these scenarios?"
    },
    {
      "content": "Remember that the input graph is connected. This means that starting from the given node, you should be able to reach all other nodes."
    },
    {
      "content": "Pay attention to the return format. You need to return the cloned node as a reference to the cloned graph, which is the same node as the original but with its neighbors cloned."
    },
    {
      "content": "To implement the cloning function, you can start by defining a recursive function that takes a node as input. Inside this function, check if the node has already been cloned using your mapping."
    }
  ],
  "questionNotes": [
    "Each node contains a unique value and a list of neighbors.",
    "The graph is connected and undirected.",
    "The input node will always be the first node with val = 1.",
    "The return value must be a reference to the cloned graph starting from the given node.",
    "Constraints: 0 <= number of nodes <= 100, 1 <= Node.val <= 100, no repeated edges or self-loops."
  ]
}