{
  "hints": [
    {
      "content": "Start by understanding the structure of a Binary Search Tree (BST). Each node's left children are smaller and right children are larger. This property will be crucial for traversing the tree."
    },
    {
      "content": "Consider how you would traverse the tree to access the nodes in a way that allows you to calculate the sum of all greater keys. A reverse in-order traversal (right, root, left) is a good approach for this."
    },
    {
      "content": "As you traverse the tree, maintain a running sum of the values you've encountered. This will help you update each node's value correctly based on the sum of all greater nodes."
    },
    {
      "content": "Think about how you will update the value of each node. You will need to replace the current node's value with the running sum when you visit it during the traversal."
    },
    {
      "content": "Remember to initialize your running sum before starting the traversal. This sum will accumulate the values of the nodes as you visit them in the correct order."
    },
    {
      "content": "Consider edge cases such as an empty tree. What should your function return if the root is null? Make sure your implementation can handle this gracefully."
    },
    {
      "content": "When implementing the traversal, you might want to use a recursive function. Think about how you can pass the running sum as an argument to keep it updated as you go deeper into the tree."
    },
    {
      "content": "Make sure that after you update a node's value, you also update the running sum accordingly. This ensures that the next node you visit has the correct sum of all greater nodes."
    },
    {
      "content": "Consider how to handle the return value of your function. You should return the modified tree, which will be the same tree structure but with updated node values."
    },
    {
      "content": "Finally, your function should modify the tree in place. Ensure that you are not creating new nodes but rather updating the existing ones with their new values."
    }
  ],
  "questionNotes": [
    "The input is a valid binary search tree.",
    "All node values are unique.",
    "The output should also be a binary search tree with updated values.",
    "Handle edge cases like an empty tree (return null).",
    "The number of nodes can be up to 10,000."
  ]
}