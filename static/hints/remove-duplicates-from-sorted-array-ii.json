{
  "hints": [
    {
      "content": "Start by understanding the constraints of the problem. You need to modify the array in-place, meaning you cannot use additional arrays for storage. Think about how you can keep track of the number of unique elements as you iterate through the array."
    },
    {
      "content": "Since the array is sorted, duplicates will be adjacent to each other. This property can be leveraged to simplify the process of counting and placing unique elements."
    },
    {
      "content": "Consider using two pointers: one to iterate through the array and another to track the position where the next unique element should be placed. This way, you can maintain the order while modifying the array."
    },
    {
      "content": "Remember that each unique element can appear at most twice. As you iterate, keep a count of how many times the current element has been added to the result. This will help you decide when to skip adding a new occurrence."
    },
    {
      "content": "Think about edge cases, such as when the array has only one element or when all elements are the same. How should your algorithm handle these scenarios?"
    },
    {
      "content": "When you encounter a new element, reset your count and place it in the next available position. If you encounter a duplicate, check how many times it has already been placed before deciding whether to add it again."
    },
    {
      "content": "Make sure to return the correct value of k, which represents the number of unique elements that have been placed in the modified array. This value is crucial for the validation of your solution."
    },
    {
      "content": "As you implement your solution, consider using a simple loop to traverse the array. For each element, compare it to the last unique element added to the result to decide whether to add it or not."
    },
    {
      "content": "Your loop should continue until you reach the end of the array. Pay attention to how you manage the index for placing elements and the index for iterating through the array."
    },
    {
      "content": "Finally, after implementing the logic, test your solution with various edge cases, including arrays with all unique elements, arrays with all duplicates, and arrays with a mix of both. Ensure that your output matches the expected format."
    }
  ],
  "questionNotes": [
    "You must modify the input array in-place.",
    "Each unique element can appear at most twice.",
    "The array is sorted in non-decreasing order.",
    "Return the number of unique elements (k) after modification.",
    "The elements beyond the first k do not matter."
  ]
}