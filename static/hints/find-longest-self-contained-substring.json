{
  "hints": [
    {
      "content": "Start by understanding what a 'self-contained substring' means. A substring is self-contained if it does not contain any repeating characters. For example, in 'abc', all characters are unique, so it's self-contained."
    },
    {
      "content": "Consider how you can identify the boundaries of a self-contained substring. You might want to use two pointers or indices to track the start and end of your current substring."
    },
    {
      "content": "Think about how you can efficiently check for repeating characters within the current substring. You could use a data structure like a set to keep track of characters you've already seen."
    },
    {
      "content": "When iterating through the string, if you encounter a repeating character, what should you do? You may need to adjust your starting index to ensure your substring remains self-contained."
    },
    {
      "content": "Consider edge cases, such as strings with all unique characters or strings where all characters are the same. How would your approach handle these scenarios?"
    },
    {
      "content": "You may want to initialize a variable to store the maximum length of any self-contained substring you find. This will help you keep track of your result as you iterate."
    },
    {
      "content": "As you iterate through the string, whenever you find a new character that is not in your current substring, you can expand your end pointer. This helps in growing the substring."
    },
    {
      "content": "When you find a repeating character, you need to move your start pointer. A good strategy is to move it to the index just after the first occurrence of that character."
    },
    {
      "content": "To find the first occurrence of a character, you can use a dictionary to store the last seen index of each character. This allows you to quickly adjust your start pointer."
    },
    {
      "content": "Make sure to update your maximum length variable whenever you find a new self-contained substring that is longer than the previously recorded maximum."
    },
    {
      "content": "Think about how you will return your result. The problem asks for the length of the longest self-contained substring, so ensure you return that value."
    },
    {
      "content": "Consider the time complexity of your approach. You should aim for a solution that runs in linear time, O(n), since you are processing each character in the string."
    },
    {
      "content": "Remember to handle empty strings as a special case. An empty string should return a length of 0, as there are no substrings to consider."
    },
    {
      "content": "When implementing your solution, be careful with the indices. Make sure you are not accessing out of bounds when adjusting your pointers."
    },
    {
      "content": "Finally, think about how you will test your solution. Prepare a variety of test cases, including edge cases like a single character string or a string with all unique characters."
    }
  ],
  "questionNotes": [
    "The substring must not contain any repeating characters.",
    "Return the length of the longest self-contained substring.",
    "Consider edge cases like empty strings or strings with all identical characters.",
    "Aim for a linear time complexity, O(n).",
    "Use appropriate data structures to track character occurrences efficiently."
  ]
}