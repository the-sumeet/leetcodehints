{
  "hints": [
    {
      "content": "The array `nums` is sorted in non-decreasing order. This means that if you find a duplicate, it will be adjacent to the first occurrence of that number. Think about how you can leverage this property to identify duplicates."
    },
    {
      "content": "You need to modify the array in-place, which means you cannot use additional arrays or data structures to store the unique elements. Consider how you can rearrange the elements within the existing array."
    },
    {
      "content": "To keep track of unique elements, you can use a pointer to indicate the position where the next unique element should be placed. This pointer will help you overwrite duplicates as you encounter them."
    },
    {
      "content": "Start iterating through the array from the second element (index 1). Compare each element with the previous one to check for duplicates. If they are different, you will need to update your pointer and place the unique element at that position."
    },
    {
      "content": "Remember to return the count of unique elements, which is the final position of your pointer. This count will represent how many unique elements are present in the modified array."
    },
    {
      "content": "Consider edge cases, such as when the input array has only one element or when all elements are the same. How would your logic handle these scenarios?"
    },
    {
      "content": "As you iterate, maintain a variable (let's call it `k`) that represents the count of unique elements. Each time you find a unique element, increment `k` and place the element at `nums[k]`."
    },
    {
      "content": "When you finish iterating through the array, `k` will give you the number of unique elements. The first `k` elements of `nums` will contain the unique values, while the rest can be ignored."
    },
    {
      "content": "Make sure to test your function with different test cases, especially edge cases like an empty array or an array with all identical elements. This will help ensure your solution is robust."
    },
    {
      "content": "Your final implementation should look something like this: Initialize a pointer at the start, loop through the array, and update the pointer and count as you find unique elements. Don't forget to return the count at the end."
    }
  ],
  "questionNotes": [
    "The array is sorted in non-decreasing order.",
    "You must modify the array in-place.",
    "Return the number of unique elements in the array.",
    "The elements after the first k can be anything; their values do not matter."
  ]
}