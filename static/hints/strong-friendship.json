{
  "hints": [
    {
      "content": "Start by understanding the structure of the input data. You have a list of friendships represented as pairs of user IDs. Each pair indicates a bidirectional relationship between two users."
    },
    {
      "content": "Think about how you can represent these friendships. A common approach is to use a graph where each user is a node and each friendship is an edge connecting two nodes."
    },
    {
      "content": "Consider how you will store the friendships. An adjacency list or a set of pairs might be useful. This will allow you to easily check connections between users."
    },
    {
      "content": "Focus on what 'strong friendship' means in this context. You might need to define criteria for how many mutual friends two users must have to be considered strongly friends."
    },
    {
      "content": "As you analyze the friendships, think about using a nested loop to compare each user with every other user. This will help you count mutual friends efficiently."
    },
    {
      "content": "Remember to handle cases where users have no friends or when the friendship list is empty. These edge cases can lead to errors if not considered."
    },
    {
      "content": "When counting mutual friends, ensure you don't double-count. You might want to use a set to keep track of unique friends for each user."
    },
    {
      "content": "After counting mutual friends, think about how to store the results. You may want to create a list of pairs that meet your 'strong friendship' criteria."
    },
    {
      "content": "Consider sorting or filtering the results based on the number of mutual friends. This can help in identifying the strongest friendships more easily."
    },
    {
      "content": "Finally, ensure your solution handles ties correctly. If two pairs have the same number of mutual friends, think about how you will decide which pair to return."
    }
  ],
  "questionNotes": [
    "Input is a list of friendships represented as pairs of user IDs.",
    "Friendships are bidirectional; (user1, user2) is the same as (user2, user1).",
    "You need to define what constitutes a 'strong friendship' based on mutual friends.",
    "Consider edge cases like users with no friends or an empty friendship list.",
    "Results should be stored in a way that allows for easy sorting and filtering."
  ]
}