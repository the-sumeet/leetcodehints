{
  "hints": [
    {
      "content": "Start by understanding the properties of a height-balanced binary search tree (BST). A BST must have its left subtree containing only nodes with values less than the node's value, and the right subtree containing only nodes with values greater than the node's value."
    },
    {
      "content": "Consider how the sorted nature of the linked list can be leveraged to create the BST. The middle element of the linked list can serve as the root of the BST, as it ensures that the left and right subtrees are balanced."
    },
    {
      "content": "Think about how you can find the middle element of the linked list. You might want to use the 'slow and fast pointer' technique to identify the middle node efficiently."
    },
    {
      "content": "Once you identify the middle element, remember to split the linked list into two halves: the left half containing elements before the middle, and the right half containing elements after the middle."
    },
    {
      "content": "You will need a recursive approach to construct the left and right subtrees. After finding the middle node and creating the root, recursively apply the same logic to the left and right halves of the linked list."
    },
    {
      "content": "Consider the base case for your recursion. If the linked list is empty, you should return null, as there are no nodes to form a tree."
    },
    {
      "content": "When constructing the tree, ensure that you are properly linking the left and right children of each node. This will maintain the structure of the binary search tree."
    },
    {
      "content": "Think about how you will represent the tree structure in your final output. Typically, you might want to return the root node of the BST after constructing it."
    },
    {
      "content": "Make sure to handle edge cases, such as when the input linked list is empty. Your function should return an appropriate representation of an empty tree."
    },
    {
      "content": "To summarize, you need to: 1) Find the middle of the linked list, 2) Create a tree node from it, 3) Recursively do the same for the left and right halves. Start implementing this step by step!"
    }
  ],
  "questionNotes": [
    "The input is a singly linked list sorted in ascending order.",
    "The output should be a height-balanced binary search tree.",
    "The number of nodes in the linked list is between 0 and 20,000.",
    "Node values are between -10^5 and 10^5."
  ]
}