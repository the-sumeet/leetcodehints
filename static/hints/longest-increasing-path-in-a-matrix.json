{
  "hints": [
    {
      "content": "Start by understanding the problem statement clearly. You need to find the longest increasing path in a matrix, where you can only move up, down, left, or right."
    },
    {
      "content": "Consider how you will traverse the matrix. Depth-first search (DFS) is a common approach for problems involving paths in a grid. Think about how you can explore each cell and its neighbors."
    },
    {
      "content": "Remember that you can only move to a cell if it has a greater value than the current cell. This is crucial for maintaining the increasing order of the path."
    },
    {
      "content": "Think about how to handle cells that have already been visited. You might want to cache results to avoid recalculating the longest path from the same cell multiple times."
    },
    {
      "content": "Consider using a memoization technique. You can create a 2D array to store the length of the longest increasing path starting from each cell."
    },
    {
      "content": "Before implementing the DFS, ensure you handle edge cases, such as an empty matrix. What should your function return in such cases?"
    },
    {
      "content": "When implementing the DFS, make sure to check the boundaries of the matrix to avoid index out of range errors. You can use conditions to ensure your indices are valid."
    },
    {
      "content": "As you explore each cell, remember to mark it as visited or use memoization to store the result of the longest path from that cell to avoid redundant calculations."
    },
    {
      "content": "Think about how you will initiate the DFS from each cell in the matrix. You might want to loop through each cell and call your DFS function."
    },
    {
      "content": "While exploring neighbors, you should only consider moving to cells that have a higher value than the current cell. This ensures the path remains increasing."
    },
    {
      "content": "After exploring all paths from a cell, update the memoization table with the maximum length found. This will help in building the solution for other cells."
    },
    {
      "content": "Once you have the longest paths calculated for all cells, find the maximum value in your memoization table. This will give you the length of the longest increasing path."
    },
    {
      "content": "Consider the time complexity of your approach. A naive DFS could lead to exponential time complexity, so memoization is key to optimizing your solution."
    },
    {
      "content": "Make sure to test your solution with various edge cases, such as matrices with all identical values, or matrices that are strictly increasing or decreasing."
    },
    {
      "content": "Finally, remember to return the length of the longest increasing path as your result, not the path itself. Ensure your function signature matches the requirements."
    }
  ],
  "questionNotes": [
    "Constraints: 1 <= m, n <= 200, 0 <= matrix[i][j] <= 2^31 - 1.",
    "You cannot move diagonally or wrap around the matrix boundaries.",
    "The return value should be the length of the longest increasing path, not the path itself."
  ]
}