{
  "hints": [
    {
      "content": "Start by understanding the goal: you need to maximize the number of indices where the permuted array has elements greater than the original array. Think about how you can rearrange the elements to achieve this."
    },
    {
      "content": "Consider sorting the original array. Sorting can help you easily compare elements and decide how to construct the permuted array. What happens if you sort the array in ascending order?"
    },
    {
      "content": "Once you have a sorted array, think about how you can use a two-pointer technique. One pointer can iterate through the sorted array while the other can track the indices of the original array."
    },
    {
      "content": "Remember that you can use each number in the sorted array only once. How can you ensure that you only select elements that are greater than the current element in the original array?"
    },
    {
      "content": "As you iterate through the original array, try to maintain a count of how many times you successfully find a greater element from the sorted array. What conditions would you check for this?"
    },
    {
      "content": "Consider edge cases, such as when all elements in the original array are the same. How would your approach handle this scenario? What would the maximum greatness be?"
    },
    {
      "content": "Think about the time complexity of your approach. Sorting the array takes O(n log n) time, but how can you ensure that the subsequent operations remain efficient?"
    },
    {
      "content": "Try to visualize the process: if you have a sorted array and you want to maximize greatness, how can you systematically choose elements from the sorted array to compare against the original array?"
    },
    {
      "content": "When implementing your solution, ensure that you correctly handle indices and avoid using the same element more than once. How will you keep track of which elements have been used?"
    },
    {
      "content": "Finally, think about how you will return the result. You need to return the count of indices where perm[i] > nums[i]. Make sure your final implementation correctly reflects this."
    }
  ],
  "questionNotes": [
    "Constraints: 1 <= nums.length <= 10^5",
    "Values: 0 <= nums[i] <= 10^9",
    "Return the maximum count of indices where perm[i] > nums[i].",
    "Ensure to consider the uniqueness of elements and avoid using the same element more than once."
  ]
}