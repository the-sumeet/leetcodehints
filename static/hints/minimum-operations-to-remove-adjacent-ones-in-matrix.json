{
  "hints": [
    {
      "content": "Start by understanding the structure of the matrix. Each element can either be 0 or 1. Your goal is to remove adjacent ones, so focus on how they are positioned relative to each other."
    },
    {
      "content": "Consider how you can traverse the matrix. A common approach is to use a depth-first search (DFS) or breadth-first search (BFS) to explore the connected components of ones."
    },
    {
      "content": "Think about how you can keep track of visited cells. You don't want to count the same group of adjacent ones multiple times. Use a boolean array or modify the matrix temporarily."
    },
    {
      "content": "What happens when you encounter a 0? You might want to skip it, but remember that it can serve as a boundary for groups of ones. How will you handle transitions between 0s and 1s?"
    },
    {
      "content": "When removing adjacent ones, consider the impact on the remaining matrix. Removing one group might create new groups of adjacent ones. How can you efficiently handle this?"
    },
    {
      "content": "Think about edge cases. For example, what if the matrix is entirely filled with 0s? How many operations would you need in that case?"
    },
    {
      "content": "Consider the size of the matrix. If it's very large, how can you optimize your approach to avoid excessive computations? Look into iterative methods instead of recursive ones."
    },
    {
      "content": "You might want to maintain a count of operations. Each time you remove a group of adjacent ones, increment your operation count. How will you define when an operation is complete?"
    },
    {
      "content": "When counting operations, think about how you can represent the removal of adjacent ones. Would it be helpful to use a queue to manage which groups to process next?"
    },
    {
      "content": "What data structures could help you track the groups of ones? Consider using a set or a list to store the coordinates of the ones you are processing."
    },
    {
      "content": "After removing a group of ones, how will you determine the next group to remove? You may need to re-scan the matrix or keep track of the boundaries of the remaining ones."
    },
    {
      "content": "Remember to handle the case where the matrix has only one row or one column. How does this affect the adjacency of ones?"
    },
    {
      "content": "Think about how you can encapsulate the logic for finding and removing adjacent ones into a function. This will help keep your code organized and modular."
    },
    {
      "content": "As you approach the solution, consider the overall complexity of your algorithm. How can you ensure it runs efficiently even for larger matrices?"
    },
    {
      "content": "Finally, you should aim to return the minimum number of operations needed to remove all adjacent ones. Make sure your function's return type matches the expected output format."
    }
  ],
  "questionNotes": [
    "The matrix can contain only 0s and 1s.",
    "Adjacent ones are defined as ones that are directly next to each other either horizontally or vertically.",
    "You need to return the minimum number of operations required to remove all adjacent ones.",
    "Consider edge cases such as empty matrices or matrices filled with only 0s.",
    "The function should handle matrices of varying sizes efficiently."
  ]
}