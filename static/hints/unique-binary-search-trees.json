{
  "hints": [
    {
      "content": "Start by understanding what a Binary Search Tree (BST) is. Remember, in a BST, for any given node, all values in the left subtree are less, and all values in the right subtree are greater."
    },
    {
      "content": "Consider how many unique BSTs can be formed with a smaller number of nodes. For example, if n = 2, how many unique BSTs can you create? This will help you identify a pattern."
    },
    {
      "content": "Think about how to construct a BST using each number from 1 to n as the root. If you choose a number 'i' as the root, how many unique BSTs can you form with the numbers less than 'i' and greater than 'i'?"
    },
    {
      "content": "Use the concept of dynamic programming or recursion to solve this problem. You can define a function that calculates the number of unique BSTs for a given number of nodes."
    },
    {
      "content": "Define a base case for your recursive function. For instance, what should the function return if there are zero or one nodes? This will help you build your solution incrementally."
    },
    {
      "content": "Consider using the Catalan number formula, which is often used to find the number of unique BSTs. The nth Catalan number can be calculated using the formula: C(n) = C(0) * C(n-1) + C(1) * C(n-2) + ... + C(n-1) * C(0)."
    },
    {
      "content": "When implementing your solution, think about how to store previously computed results to avoid redundant calculations. This is where dynamic programming shines."
    },
    {
      "content": "Make sure to handle edge cases, such as when n = 0 or n = 1. What should your function return in these scenarios?"
    },
    {
      "content": "As you build your dynamic programming table, remember that the value at each index represents the number of unique BSTs that can be formed with that many nodes."
    },
    {
      "content": "Finally, implement the logic to sum the unique BST counts for all possible root choices for each subtree size. The final result will be stored in your DP table for n nodes."
    }
  ],
  "questionNotes": [
    "Constraints: 1 <= n <= 19",
    "Return the number of structurally unique BSTs with values from 1 to n.",
    "Consider using dynamic programming or recursion with memoization.",
    "Remember to handle base cases correctly."
  ]
}