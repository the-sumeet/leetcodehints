{
  "hints": [
    {
      "content": "Start by understanding the condition for marking indices. You can mark indices `i` and `j` if `2 * nums[i] <= nums[j]`. This means you need to find pairs of indices where one is at least twice the value of the other."
    },
    {
      "content": "Consider sorting the array. Sorting can help you easily find pairs that satisfy the condition `2 * nums[i] <= nums[j]`, as it will arrange the numbers in increasing order."
    },
    {
      "content": "After sorting, think about how to iterate through the array. You can use a two-pointer technique, where one pointer (`i`) can represent the smaller number and the other pointer (`j`) can represent the larger number."
    },
    {
      "content": "Remember that you can only mark unmarked indices. Once you mark an index, you cannot use it again. Keep track of which indices are marked as you go."
    },
    {
      "content": "When using the two-pointer technique, if you find a valid pair `(i, j)`, increment both pointers to mark them and move on. If the condition is not satisfied, you may need to adjust the pointers accordingly."
    },
    {
      "content": "Consider edge cases where all numbers are the same or where the array has only one element. How would these cases affect your ability to mark indices?"
    },
    {
      "content": "Think about the maximum number of indices you can mark. You can mark two indices at a time, so the total number of marked indices must be even. How does this affect your counting strategy?"
    },
    {
      "content": "As you implement your solution, keep a count of the total marked indices. Each time you successfully mark a pair, add two to your count."
    },
    {
      "content": "Make sure to handle large inputs efficiently. Your solution should ideally run in O(n log n) time complexity due to sorting, followed by O(n) for the two-pointer traversal."
    },
    {
      "content": "Finally, ensure your function returns the correct value. The return should be the total number of marked indices, which is your count variable at the end of the process."
    }
  ],
  "questionNotes": [
    "Constraints: 1 <= nums.length <= 10^5",
    "Constraints: 1 <= nums[i] <= 10^9",
    "Indices are 0-indexed.",
    "Marking indices is a one-time operation; once marked, they cannot be used again.",
    "Return the maximum number of marked indices."
  ]
}