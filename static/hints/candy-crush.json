{
  "hints": [
    {
      "content": "Start by understanding the grid structure of the input. Each sub-array represents a row in the grid, and each element represents a candy type. Consider how you will traverse this grid to identify clusters of candies."
    },
    {
      "content": "Think about how to identify groups of three or more adjacent candies of the same type. You might want to use a depth-first search (DFS) or breadth-first search (BFS) to explore connected candies."
    },
    {
      "content": "When you find a group of candies to crush, remember that you need to mark them for removal. Consider using a separate data structure to keep track of which candies will be removed after processing the entire grid."
    },
    {
      "content": "After marking the candies for removal, think about how to handle the candies above them. They should fall down to fill the empty spaces. You may need to implement a function to simulate this falling action."
    },
    {
      "content": "Consider edge cases, such as when there are no candies to crush or when the grid is already in a stable state. Make sure your algorithm can handle these scenarios gracefully."
    },
    {
      "content": "As you implement the crush and fall logic, remember to check for new groups of candies that may form after the initial crush. You might need to repeat the process until no more candies can be crushed."
    },
    {
      "content": "Keep track of the number of candies crushed in each operation. You may want to return this count as part of your final result. Think about how to accumulate this count efficiently."
    },
    {
      "content": "While implementing the crush logic, ensure that you are not modifying the grid while iterating through it. This can lead to unexpected behavior. Consider using a copy of the grid or a separate marking system."
    },
    {
      "content": "Once you have the basic crush and fall mechanics working, test your solution with various grid sizes and configurations. Pay attention to edge cases, such as grids filled with the same candy type."
    },
    {
      "content": "Finally, consider how you will return the final state of the grid after all possible candies have been crushed. You might want to return the modified grid along with the total count of candies crushed."
    }
  ],
  "questionNotes": [
    "The input is a 2D grid where each element represents a candy type.",
    "You need to find and crush groups of three or more adjacent candies of the same type.",
    "After crushing, candies above should fall down to fill empty spaces.",
    "The process may need to repeat until no more candies can be crushed.",
    "Return the final state of the grid and the total number of candies crushed."
  ]
}