{
  "hints": [
    {
      "content": "Start by understanding the movement rules. You can move to any cell in the same row or column, but only if the destination cell's value is strictly greater than the current cell's value."
    },
    {
      "content": "Consider how you would explore the matrix. A depth-first search (DFS) or breadth-first search (BFS) could be useful to explore all possible paths from a starting cell."
    },
    {
      "content": "Think about how you can keep track of the cells you have visited. You might want to use a set or a boolean array to avoid revisiting cells during your exploration."
    },
    {
      "content": "Since the matrix can be large (up to 100,000 cells), ensure that your approach is efficient. Avoid unnecessary recalculations by storing results of previously computed paths."
    },
    {
      "content": "Consider using dynamic programming (DP) to store the maximum path length starting from each cell. This can help you avoid recalculating paths for cells that have already been processed."
    },
    {
      "content": "When implementing your DP solution, think about how you would fill in the DP table. You might want to process cells in a specific order, such as sorting them based on their values."
    },
    {
      "content": "Pay attention to edge cases, such as when all values in the matrix are the same. In such cases, the maximum number of cells visited will be 1."
    },
    {
      "content": "You might want to create a helper function that, given a starting cell, calculates the maximum number of cells that can be visited from that cell."
    },
    {
      "content": "Consider how you can optimize your search by only exploring cells that have not been visited or are not part of a previously calculated path."
    },
    {
      "content": "As you implement your solution, remember to return the maximum number of cells visited across all starting points in the matrix."
    },
    {
      "content": "Think about how you can handle the constraints effectively. Since the matrix can be as large as 100,000 cells, ensure your approach runs in a reasonable time complexity, ideally O(m * n)."
    },
    {
      "content": "Make sure to handle the matrix indexing correctly. Remember that the problem uses 1-indexing, while most programming languages use 0-indexing."
    },
    {
      "content": "You may want to keep track of the maximum path length found so far as you iterate through each cell in the matrix."
    },
    {
      "content": "Consider using a priority queue to explore the cells in order of their values, which might help in efficiently finding the next valid cell to move to."
    },
    {
      "content": "Finally, ensure your solution handles all edge cases correctly, including matrices with negative values or very large positive values."
    }
  ],
  "questionNotes": [
    "1-indexed matrix: Be careful with indexing when implementing your solution.",
    "Constraints: m, n can be as large as 100,000, but m * n <= 100,000.",
    "All values can range from -100,000 to 100,000.",
    "The return value should be an integer representing the maximum cells visited."
  ]
}