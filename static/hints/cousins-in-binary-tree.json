{
  "hints": [
    {
      "content": "Start by understanding the structure of a binary tree. Each node has a unique value, and you need to determine the depth of each node in relation to the root."
    },
    {
      "content": "Remember that cousins must be at the same depth in the tree. Consider how you would traverse the tree to find the depth of nodes x and y."
    },
    {
      "content": "You may want to use a breadth-first search (BFS) or depth-first search (DFS) approach to explore the tree. Think about how you can keep track of the depth of each node as you traverse."
    },
    {
      "content": "As you traverse, also keep track of the parent of each node. You need to ensure that x and y have different parents to confirm they are cousins."
    },
    {
      "content": "When you find the nodes with values x and y, check their depths. If they are at the same depth, proceed to check their parents."
    },
    {
      "content": "Consider edge cases where the tree might be skewed (like a linked list) or where x and y are siblings. How would these cases affect your checks?"
    },
    {
      "content": "You can use a queue to implement BFS, where you store pairs of nodes along with their depth and parent information. For example, enqueue (node, depth, parent)."
    },
    {
      "content": "Once you find both nodes, compare their depths first. If they are not equal, return false immediately."
    },
    {
      "content": "If the depths are equal, check if the parents of both nodes are different. This will determine if they are cousins."
    },
    {
      "content": "Make sure to handle the case where either x or y might not be found in the tree, although the problem guarantees that both exist."
    }
  ],
  "questionNotes": [
    "The binary tree has unique values.",
    "x and y are guaranteed to exist in the tree and are different.",
    "Cousins must be at the same depth but have different parents.",
    "The root node is at depth 0, and its children are at depth 1."
  ]
}