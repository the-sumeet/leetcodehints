{
  "hints": [
    {
      "content": "Start by understanding the basic definition of Fibonacci numbers. Recall that F(0) = 0 and F(1) = 1. For any n greater than 1, F(n) is the sum of the two preceding Fibonacci numbers: F(n) = F(n - 1) + F(n - 2)."
    },
    {
      "content": "Consider how you would compute Fibonacci numbers for small values of n. For example, calculate F(2) and F(3) manually to see the pattern. This will help you understand the recursive nature of the sequence."
    },
    {
      "content": "Think about the base cases in your implementation. You need to handle F(0) and F(1) separately since they do not follow the general rule. How will you return these values directly?"
    },
    {
      "content": "If you were to implement a recursive solution, what would be the stopping condition? Make sure to include checks for n = 0 and n = 1 to avoid unnecessary calculations."
    },
    {
      "content": "Consider the efficiency of your approach. A naive recursive solution can lead to a lot of repeated calculations. What technique could you use to optimize this, such as memoization or an iterative approach?"
    },
    {
      "content": "If you're thinking about an iterative solution, how would you keep track of the last two Fibonacci numbers? You might want to use two variables to store these values and update them as you compute higher Fibonacci numbers."
    },
    {
      "content": "Remember the constraints given in the problem. You only need to compute Fibonacci numbers for n in the range of 0 to 30. This means you can afford to use a simple loop without worrying about performance issues."
    },
    {
      "content": "When implementing your solution, think about the return type. Since Fibonacci numbers can grow quickly, ensure that your return type can handle the maximum value for F(30). In Python, for example, integers can grow as needed."
    },
    {
      "content": "Before finalizing your solution, test it with edge cases. What will your function return for inputs like n = 0 and n = 1? Ensure your implementation handles these cases correctly."
    },
    {
      "content": "You're almost there! To complete your function, consider how you will implement the loop or recursion to calculate F(n) based on the previous values. Focus on the logic that updates your variables for each step."
    }
  ],
  "questionNotes": [
    "Constraints: 0 <= n <= 30",
    "Fibonacci sequence starts with F(0) = 0 and F(1) = 1.",
    "Return the Fibonacci number for the given n."
  ]
}