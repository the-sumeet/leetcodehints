{
  "hints": [
    {
      "content": "Start by understanding what a Binary Search Tree (BST) is. Recall that for a tree to be a BST, for any node, all values in its left subtree must be less than the node's value, and all values in its right subtree must be greater."
    },
    {
      "content": "Consider how you would traverse the tree. A common approach is to use Depth-First Search (DFS) or Breadth-First Search (BFS). Think about how you could keep track of the current node and its properties during the traversal."
    },
    {
      "content": "As you traverse the tree, you need to determine if the current subtree is a BST. This involves checking the values of the nodes and ensuring they satisfy the BST properties. You might want to return both the size of the subtree and the min/max values."
    },
    {
      "content": "What data do you need to keep track of while checking if a subtree is a BST? Consider using a helper function that returns multiple values: whether the subtree is a BST, its size, and its min and max values."
    },
    {
      "content": "Think about how to handle the base case in your recursive function. If you reach a null node, how should you define its properties in terms of being a BST? What size should it return?"
    },
    {
      "content": "When checking if a subtree rooted at a node is a BST, ensure that the node's value is greater than the maximum value of its left subtree and less than the minimum value of its right subtree."
    },
    {
      "content": "As you calculate the size of valid BSTs, keep track of the largest size found so far. You may want to use a global variable or pass it up through your recursive calls."
    },
    {
      "content": "Consider edge cases, such as trees with only one node or completely unbalanced trees. What should your function return in these scenarios?"
    },
    {
      "content": "Make sure to test your function with various tree structures. For instance, how does it perform with trees that have duplicate values? Remember that BSTs do not allow duplicates."
    },
    {
      "content": "Finally, implement your function to return the size of the largest BST subtree found. Ensure that you are correctly updating the maximum size as you explore each subtree."
    }
  ],
  "questionNotes": [
    "Input is a binary tree represented as an array, where 'null' indicates the absence of a node.",
    "The output should be the size of the largest BST subtree.",
    "Consider edge cases like empty trees or trees with only one node.",
    "BST properties must be strictly followed (no duplicate values allowed)."
  ]
}